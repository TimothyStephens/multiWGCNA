---
title: "General Workflow"
author: "Dario Tommasini"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{General Workflow}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(multiWGCNA)
```

Step 0: Install the multiWGCNA R package. 

```{r eval=FALSE}
if(!require(devtools)) install.packages("devtools")
devtools::install_github("fogellab/multiWGCNA")
```

Step 1: Read in microarray data from human post-mortem brains from Voineagu et al. 2011 (https://www.nature.com/articles/nature10110), which has two sample traits: 1) autism versus control, and 2) temporal cortex versus frontal cortex. Since this is purely an example of how to run the entire analysis from start to finish, we are going to limit our analysis to 2000 randomly selected probes (so do not take the results too seriously since we are downsampling so much). Let's also set some useful global variables, like the alpha level of significance and the soft thresholding power for our network. Notice that the gene names in datExpr should be in column 1 named "X".  

```{r}
# Load the data provided in the package
data(autism_data) # expression matrix
data(autism_metadata) # metadata

datExpr = autism_data
sampleTable = autism_metadata

# Randomly sample 2000 genes from the expression matrix
set.seed(1)
datExpr = datExpr[sample(rownames(datExpr), 2000),]

# Check the data
datExpr[1:5,1:5]
sampleTable

# Set the alpha level for statistical analyses and the soft power for network construction
alphaLevel = 0.05
softPower = 10

# If your sample traits include numbers that you'd like to be considered numerical 
# variables rather than categorical variables, set detectNumbers = TRUE
detectNumbers = FALSE
```

step 2: Perform network construction, module eigengene calculation, module-trait correlation. Also, let's find best trait for each module and identify outlier modules (ie modules driven by a single sample). 

Let's use power = 10 since Voineagu et al. 2011 used that for all their networks. They also constructed "unsigned" networks and a mergeCutHeight of 0.10 so that modules with similar expression are merged. This step may take a while. 

```{r}
# Define our conditions for trait 1 (disease) and 2 (brain region)
conditions1=unique(sampleTable[,2])
conditions2=unique(sampleTable[,3])

# Construct the combined networks and all the sub-networks (autism only, controls only, FC only, and TC only)
# We use the same parameters from Voineagu et al. Nature. 2011. 
myNetworks=constructNetworks(datExpr, sampleTable, conditions1, conditions2, 
                                  networkType = "unsigned", power = 10, 
                                  minModuleSize = 40, maxBlockSize = 25000, 
                                  reassignThreshold = 0, minKMEtoStay = 0.7, 
                                  mergeCutHeight = 0.10, numericLabels = TRUE, 
                                  pamRespectsDendro = FALSE, verbose=3)
```

Step 3: Compare modules (by hypergeometric overlap) across conditions. We'll save the results in a list. Then, let's take a look at the mutual best matches between autism modules and control modules. 

```{r, fig.height = 5, fig.width = 8}
# Save results to a list
results=list()
results$overlaps=iterate(myNetworks, overlapComparisons, plot=TRUE)

# Check the reciprocal best matches between the autism and control networks
head(results$overlaps$autism_vs_controls$bestMatches)
```

Step 4: Perform differential module expression analysis. This test for an association between the module eigengene (ME) and the two sample traits or their interaction. Therefore, the model is ME = trait1 + trait2 + trait1*trait2 and tests for a significant association to the traits using factorial ANOVA. These results can be stored in the diffModExp component of the results list. It can also perform PERMANOVA, which uses multivariate distances and can thus be applied to the module expression rather than just the first principal component (module eigengene). 

Module combined_005 seems to be the module most significantly associated with disease status using standard ANOVA (module combined_000 represents genes that were unassigned so disregard this module). Let's use the diffModuleExpression function to visually check this module for an association to autism status. 

Note: By setting plot = TRUE, the runDME function generates a PDF file called "combined_DME.pdf" in the current directory with these plots for all the modules. 

```{r, fig.height = 6, fig.width = 7}
# Run differential module expression analysis (DME) on combined networks
results$diffModExp = runDME(myNetworks[["combined"]], 
                            p.adjust="fdr", 
                            refCondition="Tissue", 
                            testCondition="Status") 
                            # plot=TRUE, 
                            # out="ANOVA_DME.pdf")

# to run PERMANNOVA
# results$diffModExp = runDME(myNetworks[["combined"]], p.adjust="fdr", refCondition="Tissue", 
#                          testCondition="Status", plot=TRUE, test="PERMANOVA", out="PERMANOVA_DME.pdf")

# Check FDR-adjusted associations to the two sample traits
results$diffModExp

# You can check the expression of a specific module like this. Note that the values reported in the bottom panel title are p-values and not FDR-adjusted like in results$diffModExp
diffModuleExpression(myNetworks[["combined"]], 
                     geneList = topNGenes(myNetworks[["combined"]], "combined_005"), 
                     test = "ANOVA",
                     design = sampleTable,
                     moduleName = "combined_005",
                     plot = TRUE)

```

Step 5: Perform the module preservation analysis to determine if any  modules in the autism data are not preserved in the healthy data (or vice versa). This is the slowest step as the calculation of permuted statistics takes a while. Typically, this can be parallelized using the enableWGCNAThreads function, but for this vignette we'll just do 20 permutations so two cores should be fine.   

```{r, fig.height = 3, fig.width = 7}
# To enable multi-threading
# library(doParallel)
# library(WGCNA)
# nCores = 2
# registerDoParallel(cores = nCores)
# enableWGCNAThreads(nThreads = nCores)

# Calculate preservation statistics
results$preservation=iterate(myNetworks[conditions1], # change to conditions2 to perform comparison between FC and TC
                             preservationComparisons, 
                             write=FALSE, 
                             plot=TRUE, 
                             nPermutations=20)
```

Step 6: Summarize interesting results from the analyses, namely non-preserved trait-associated modules and differentially expressed modules. 

```{r}
# Print a summary of the results
summarizeResults(myNetworks, results)
```
